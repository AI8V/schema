/**
 * @file dynamicPromptGenerator-en.js
 * @description A standalone module to generate a dynamic and specialized AI prompt.
 * @version 2.0.1
 * @author Your Name/Company
 *
 * This module implements a hardened "Dynamic Prompt Engineering" strategy.
 * It takes the user-selected schema type as input and produces a complete,
 * tailored prompt that instructs an AI model to enhance a pre-existing schema structure.
 */

// We use the "Module Pattern" to create a private scope and prevent polluting the global scope.
const DynamicPromptGenerator = (function () {

    // ===================================================================
    //  1. The Master Prompt Template (v2.0)
    // ===================================================================

    /**
     * The final, hardened master prompt template.
     * It uses `{{SCHEMA_TYPE}}` as a dynamic placeholder.
     * This prompt forces the AI to act as an enhancer, not a creator.
     * @type {string}
     */
    const PROMPT_TEMPLATE = `You are an expert Schema Auditor. Your task is to improve a pre-existing JSON-LD code, not create one from scratch.

I will provide you with three inputs:
1.  \`page.html\`: The original content file.
2.  \`base_schema.jsonld\`: This is the **base, authoritative structure** generated by our tool. **You must treat this structure as the single source of truth for the overall architecture.**
3.  \`PRIMARY_ENTITY_TYPE\`: A string variable specifying the chosen primary entity, with the value **\`{{SCHEMA_TYPE}}\`**.

**Your required task is to follow this strict algorithm, step-by-step, without deviation:**

**Phase 1: In-Place Enhancement**
1.  Start with the \`base_schema.jsonld\` file as is. **Do not change the order of fields or its fundamental structure at this stage.**
2.  **Data Sanitization:**
    *   Go to the \`sku\` field and clean its value to be only the actual code (e.g., "KF-PCX1-2025").
    *   Go to the \`price\` field and clean its value to be only the decimal number (e.g., "999.00").
3.  **Add \`review\` Property:**
    *   Only if \`PRIMARY_ENTITY_TYPE\` is \`Product\`, check for the existence of article data (author and publication date) in the \`base_schema.jsonld\` file (it might be inside \`hasPart\` or at the top level).
    *   If found, create a \`"review"\` property within the main product object. Move the author and date data into it, then **delete** the entire secondary \`Article\` entity from \`hasPart\` to prevent duplication.

**Phase 2: Restructuring and Final Formatting**
1.  **Smart Detachment Rule:**
    *   Look at the enhanced structure now. If an \`FAQPage\` entity exists inside \`hasPart\` of the main entity, **detach** it from there.
    *   Create a second, completely independent \`<script type="application/ld+json">\` block and place the detached \`FAQPage\` code within it.
2.  **Validation Check:**
    *   Before finishing, self-review the final JSON-LD code. Ensure all brackets and commas are 100% correct. **This is a mandatory step.**

**Phase 3: Final Output Construction**
1.  Take the original \`page.html\` file as is.
2.  Insert all resulting \`<script>\` blocks (whether one or two) inside the \`<head>\` tag, immediately before the closing \`</head>\` tag.
3.  **Do not touch any other part of the HTML.**

**Required Final Output:**
The full HTML file content, from \`<!DOCTYPE html>\` to \`</html>\`, including the new, enhanced, and valid schema.`;


    // ===================================================================
    //  2. Public Function
    // ===================================================================

    /**
     * Generates the final prompt based on the selected schema type.
     * @param {string} selectedSchemaType - The schema type selected by the user (e.g., "Product", "Recipe").
     * @returns {string|null} - A string containing the customized prompt, or null if the input is invalid.
     */
    function generatePrompt(selectedSchemaType) {
        // Input validation to ensure no errors occur
        if (!selectedSchemaType || typeof selectedSchemaType !== 'string') {
            // i18n-key: errorInvalidSchemaType
            console.error("Error: A valid schema type must be provided.");
            return null;
        }

        // We use a regular expression (RegExp) with the 'g' (global) flag
        // to ensure all placeholders in the template are replaced, not just the first one.
        const placeholderRegex = /{{SCHEMA_TYPE}}/g;
        
        const finalPrompt = PROMPT_TEMPLATE.replace(placeholderRegex, selectedSchemaType);

        return finalPrompt;
    }

    // We return an object containing the functions we want to make public (available for external use).
    // In this case, it's only one function.
    return {
        generate: generatePrompt
    };

})();

// Note: No change is needed in "How to Use" because the module's API
// has not changed. It's still called via `DynamicPromptGenerator.generate(type)`.